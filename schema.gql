# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type FileUploadResult {
  url: String!
}

input LoginInput {
  email: String!
  password: String!
}

type LoginOutput {
  token: String
  user: User
}

type Mutation {
  createUser(input: UserCreateInput!): User!
  login(data: LoginInput!): LoginOutput
  logout: Boolean!
  register(data: RegisterInput!): User!
  uploadFile(file: Upload!, path: String): FileUploadResult!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Query {
  me: User!
  user(id: String!): User!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  usersForAdmin(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type RefreshToken {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: String!
  token: String!
  user: User!
  userId: String!
}

type RefreshTokenCountAggregate {
  _all: Int!
  createdAt: Int!
  expiresAt: Int!
  id: Int!
  token: Int!
  userId: Int!
}

input RefreshTokenCreateManyUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  id: String
  token: String!
}

input RefreshTokenCreateManyUserInputEnvelope {
  data: [RefreshTokenCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input RefreshTokenCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput!]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput!]
  create: [RefreshTokenCreateWithoutUserInput!]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  create: RefreshTokenCreateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenCreateWithoutUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  id: String
  token: String!
}

input RefreshTokenListRelationFilter {
  every: RefreshTokenWhereInput
  none: RefreshTokenWhereInput
  some: RefreshTokenWhereInput
}

type RefreshTokenMaxAggregate {
  createdAt: DateTime
  expiresAt: DateTime
  id: String
  token: String
  userId: String
}

type RefreshTokenMinAggregate {
  createdAt: DateTime
  expiresAt: DateTime
  id: String
  token: String
  userId: String
}

input RefreshTokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: StringFilter
  token: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input RefreshTokenWhereUniqueInput {
  AND: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: String
  token: String
  user: UserScalarRelationFilter
  userId: StringFilter
}

input RegisterInput {
  email: String!
  firstName: String!
  password: String!
  username: String!
}

type Role {
  _count: RoleCount!
  id: String!
  name: String!
  users: [User!]
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input RoleCreateNestedManyWithoutUsersInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutUsersInput!]
  create: [RoleCreateWithoutUsersInput!]
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  id: String
  name: String!
}

input RoleListRelationFilter {
  every: RoleWhereInput
  none: RoleWhereInput
  some: RoleWhereInput
}

type RoleMaxAggregate {
  id: String
  name: String
}

type RoleMinAggregate {
  id: String
  name: String
}

input RoleOrderByRelationAggregateInput {
  _count: SortOrder
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: String
  name: String
  users: UserListRelationFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  Role: [Role!]
  _count: UserCount!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  images: [UserImage!]
  isVerified: Boolean!
  lastName: String
  password: String!
  phone: String
  tokens: [RefreshToken!]
  updatedAt: DateTime!
  username: String!
}

type UserCount {
  Role: Int!
  images: Int!
  tokens: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  id: Int!
  isVerified: Int!
  lastName: Int!
  password: Int!
  phone: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateInput {
  Role: RoleCreateNestedManyWithoutUsersInput
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  images: UserImageCreateNestedManyWithoutUserInput
  isVerified: Boolean
  lastName: String
  password: String!
  phone: String
  tokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String!
}

type UserImage {
  id: String!
  type: String!
  url: String!
  user: User!
  userId: String!
}

type UserImageCountAggregate {
  _all: Int!
  id: Int!
  type: Int!
  url: Int!
  userId: Int!
}

input UserImageCreateManyUserInput {
  id: String
  type: String!
  url: String!
}

input UserImageCreateManyUserInputEnvelope {
  data: [UserImageCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserImageCreateNestedManyWithoutUserInput {
  connect: [UserImageWhereUniqueInput!]
  connectOrCreate: [UserImageCreateOrConnectWithoutUserInput!]
  create: [UserImageCreateWithoutUserInput!]
  createMany: UserImageCreateManyUserInputEnvelope
}

input UserImageCreateOrConnectWithoutUserInput {
  create: UserImageCreateWithoutUserInput!
  where: UserImageWhereUniqueInput!
}

input UserImageCreateWithoutUserInput {
  id: String
  type: String!
  url: String!
}

input UserImageListRelationFilter {
  every: UserImageWhereInput
  none: UserImageWhereInput
  some: UserImageWhereInput
}

type UserImageMaxAggregate {
  id: String
  type: String
  url: String
  userId: String
}

type UserImageMinAggregate {
  id: String
  type: String
  url: String
  userId: String
}

input UserImageOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserImageWhereInput {
  AND: [UserImageWhereInput!]
  NOT: [UserImageWhereInput!]
  OR: [UserImageWhereInput!]
  id: StringFilter
  type: StringFilter
  url: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserImageWhereUniqueInput {
  AND: [UserImageWhereInput!]
  NOT: [UserImageWhereInput!]
  OR: [UserImageWhereInput!]
  id: String
  type: StringFilter
  url: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  isVerified: Boolean
  lastName: String
  password: String
  phone: String
  updatedAt: DateTime
  username: String
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  isVerified: Boolean
  lastName: String
  password: String
  phone: String
  updatedAt: DateTime
  username: String
}

input UserOrderByWithRelationInput {
  Role: RoleOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  images: UserImageOrderByRelationAggregateInput
  isVerified: SortOrder
  lastName: SortOrderInput
  password: SortOrder
  phone: SortOrderInput
  tokens: RefreshTokenOrderByRelationAggregateInput
  updatedAt: SortOrder
  username: SortOrder
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  isVerified
  lastName
  password
  phone
  updatedAt
  username
}

input UserScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Role: RoleListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  images: UserImageListRelationFilter
  isVerified: BoolFilter
  lastName: StringNullableFilter
  password: StringFilter
  phone: StringNullableFilter
  tokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Role: RoleListRelationFilter
  createdAt: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  images: UserImageListRelationFilter
  isVerified: BoolFilter
  lastName: StringNullableFilter
  password: StringFilter
  phone: StringNullableFilter
  tokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeFilter
  username: String
}