# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Documets {
  createdAt: DateTime!
  id: String!
  type: String
  uniqueId: String!
  url: String
  user: User!
  userId: String!
}

type DocumetsCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  type: Int!
  uniqueId: Int!
  url: Int!
  userId: Int!
}

input DocumetsCreateManyUserInput {
  createdAt: DateTime
  id: String
  type: String
  uniqueId: String!
  url: String
}

input DocumetsCreateManyUserInputEnvelope {
  data: [DocumetsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input DocumetsCreateNestedManyWithoutUserInput {
  connect: [DocumetsWhereUniqueInput!]
  connectOrCreate: [DocumetsCreateOrConnectWithoutUserInput!]
  create: [DocumetsCreateWithoutUserInput!]
  createMany: DocumetsCreateManyUserInputEnvelope
}

input DocumetsCreateOrConnectWithoutUserInput {
  create: DocumetsCreateWithoutUserInput!
  where: DocumetsWhereUniqueInput!
}

input DocumetsCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  type: String
  uniqueId: String!
  url: String
}

input DocumetsListRelationFilter {
  every: DocumetsWhereInput
  none: DocumetsWhereInput
  some: DocumetsWhereInput
}

type DocumetsMaxAggregate {
  createdAt: DateTime
  id: String
  type: String
  uniqueId: String
  url: String
  userId: String
}

type DocumetsMinAggregate {
  createdAt: DateTime
  id: String
  type: String
  uniqueId: String
  url: String
  userId: String
}

input DocumetsOrderByRelationAggregateInput {
  _count: SortOrder
}

input DocumetsUniqueIdUserIdCompoundUniqueInput {
  uniqueId: String!
  userId: String!
}

input DocumetsWhereInput {
  AND: [DocumetsWhereInput!]
  NOT: [DocumetsWhereInput!]
  OR: [DocumetsWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  type: StringNullableFilter
  uniqueId: StringFilter
  url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input DocumetsWhereUniqueInput {
  AND: [DocumetsWhereInput!]
  NOT: [DocumetsWhereInput!]
  OR: [DocumetsWhereInput!]
  createdAt: DateTimeFilter
  id: String
  type: StringNullableFilter
  uniqueId: StringFilter
  uniqueId_userId: DocumetsUniqueIdUserIdCompoundUniqueInput
  url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

type DriverIDCards {
  id: String!
  recto_url: String
  user: User!
  userId: String!
  verso_url: String
}

type DriverIDCardsCountAggregate {
  _all: Int!
  id: Int!
  recto_url: Int!
  userId: Int!
  verso_url: Int!
}

input DriverIDCardsCreateManyUserInput {
  id: String
  recto_url: String
  verso_url: String
}

input DriverIDCardsCreateManyUserInputEnvelope {
  data: [DriverIDCardsCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input DriverIDCardsCreateNestedManyWithoutUserInput {
  connect: [DriverIDCardsWhereUniqueInput!]
  connectOrCreate: [DriverIDCardsCreateOrConnectWithoutUserInput!]
  create: [DriverIDCardsCreateWithoutUserInput!]
  createMany: DriverIDCardsCreateManyUserInputEnvelope
}

input DriverIDCardsCreateOrConnectWithoutUserInput {
  create: DriverIDCardsCreateWithoutUserInput!
  where: DriverIDCardsWhereUniqueInput!
}

input DriverIDCardsCreateWithoutUserInput {
  id: String
  recto_url: String
  verso_url: String
}

input DriverIDCardsListRelationFilter {
  every: DriverIDCardsWhereInput
  none: DriverIDCardsWhereInput
  some: DriverIDCardsWhereInput
}

type DriverIDCardsMaxAggregate {
  id: String
  recto_url: String
  userId: String
  verso_url: String
}

type DriverIDCardsMinAggregate {
  id: String
  recto_url: String
  userId: String
  verso_url: String
}

input DriverIDCardsOrderByRelationAggregateInput {
  _count: SortOrder
}

input DriverIDCardsWhereInput {
  AND: [DriverIDCardsWhereInput!]
  NOT: [DriverIDCardsWhereInput!]
  OR: [DriverIDCardsWhereInput!]
  id: StringFilter
  recto_url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: StringFilter
  verso_url: StringNullableFilter
}

input DriverIDCardsWhereUniqueInput {
  AND: [DriverIDCardsWhereInput!]
  NOT: [DriverIDCardsWhereInput!]
  OR: [DriverIDCardsWhereInput!]
  id: String
  recto_url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: String
  verso_url: StringNullableFilter
}

type DriverLicense {
  id: String!
  url: String
  user: User!
  userId: String!
}

type DriverLicenseCountAggregate {
  _all: Int!
  id: Int!
  url: Int!
  userId: Int!
}

input DriverLicenseCreateManyUserInput {
  id: String
  url: String
}

input DriverLicenseCreateManyUserInputEnvelope {
  data: [DriverLicenseCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input DriverLicenseCreateNestedManyWithoutUserInput {
  connect: [DriverLicenseWhereUniqueInput!]
  connectOrCreate: [DriverLicenseCreateOrConnectWithoutUserInput!]
  create: [DriverLicenseCreateWithoutUserInput!]
  createMany: DriverLicenseCreateManyUserInputEnvelope
}

input DriverLicenseCreateOrConnectWithoutUserInput {
  create: DriverLicenseCreateWithoutUserInput!
  where: DriverLicenseWhereUniqueInput!
}

input DriverLicenseCreateWithoutUserInput {
  id: String
  url: String
}

input DriverLicenseListRelationFilter {
  every: DriverLicenseWhereInput
  none: DriverLicenseWhereInput
  some: DriverLicenseWhereInput
}

type DriverLicenseMaxAggregate {
  id: String
  url: String
  userId: String
}

type DriverLicenseMinAggregate {
  id: String
  url: String
  userId: String
}

input DriverLicenseOrderByRelationAggregateInput {
  _count: SortOrder
}

input DriverLicenseWhereInput {
  AND: [DriverLicenseWhereInput!]
  NOT: [DriverLicenseWhereInput!]
  OR: [DriverLicenseWhereInput!]
  id: StringFilter
  url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input DriverLicenseWhereUniqueInput {
  AND: [DriverLicenseWhereInput!]
  NOT: [DriverLicenseWhereInput!]
  OR: [DriverLicenseWhereInput!]
  id: String
  url: StringNullableFilter
  user: UserScalarRelationFilter
  userId: String
}

input DriverRegistrationInput {
  driverLicenseImage: Upload!
  idCardImages: Upload!
  vehicle: VehicleInput!
}

type DriverVehicle {
  DriverVehicleImg: [DriverVehicleImg!]
  _count: DriverVehicleCount!
  brand: String
  id: String!
  model: String
  place: Int!
  registrationNumber: String
  type: VehicleType!
  user: User!
  userId: String!
  vehicleTypeId: String!
}

type DriverVehicleAvgAggregate {
  place: Float
}

type DriverVehicleCount {
  DriverVehicleImg: Int!
}

type DriverVehicleCountAggregate {
  _all: Int!
  brand: Int!
  id: Int!
  model: Int!
  place: Int!
  registrationNumber: Int!
  userId: Int!
  vehicleTypeId: Int!
}

input DriverVehicleCreateManyTypeInput {
  brand: String
  id: String
  model: String
  place: Int!
  registrationNumber: String
  userId: String!
}

input DriverVehicleCreateManyTypeInputEnvelope {
  data: [DriverVehicleCreateManyTypeInput!]!
  skipDuplicates: Boolean
}

input DriverVehicleCreateManyUserInput {
  brand: String
  id: String
  model: String
  place: Int!
  registrationNumber: String
  vehicleTypeId: String!
}

input DriverVehicleCreateManyUserInputEnvelope {
  data: [DriverVehicleCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input DriverVehicleCreateNestedManyWithoutTypeInput {
  connect: [DriverVehicleWhereUniqueInput!]
  connectOrCreate: [DriverVehicleCreateOrConnectWithoutTypeInput!]
  create: [DriverVehicleCreateWithoutTypeInput!]
  createMany: DriverVehicleCreateManyTypeInputEnvelope
}

input DriverVehicleCreateNestedManyWithoutUserInput {
  connect: [DriverVehicleWhereUniqueInput!]
  connectOrCreate: [DriverVehicleCreateOrConnectWithoutUserInput!]
  create: [DriverVehicleCreateWithoutUserInput!]
  createMany: DriverVehicleCreateManyUserInputEnvelope
}

input DriverVehicleCreateOrConnectWithoutTypeInput {
  create: DriverVehicleCreateWithoutTypeInput!
  where: DriverVehicleWhereUniqueInput!
}

input DriverVehicleCreateOrConnectWithoutUserInput {
  create: DriverVehicleCreateWithoutUserInput!
  where: DriverVehicleWhereUniqueInput!
}

input DriverVehicleCreateWithoutTypeInput {
  DriverVehicleImg: DriverVehicleImgCreateNestedManyWithoutVehicleInput
  brand: String
  id: String
  model: String
  place: Int!
  registrationNumber: String
  user: UserCreateNestedOneWithoutVehiclesInput!
}

input DriverVehicleCreateWithoutUserInput {
  DriverVehicleImg: DriverVehicleImgCreateNestedManyWithoutVehicleInput
  brand: String
  id: String
  model: String
  place: Int!
  registrationNumber: String
  type: VehicleTypeCreateNestedOneWithoutVehiclesInput!
}

type DriverVehicleImg {
  category: String
  id: String!
  url: String
  vehicle: DriverVehicle!
  vehicleId: String!
}

type DriverVehicleImgCountAggregate {
  _all: Int!
  category: Int!
  id: Int!
  url: Int!
  vehicleId: Int!
}

input DriverVehicleImgCreateManyVehicleInput {
  category: String
  id: String
  url: String
}

input DriverVehicleImgCreateManyVehicleInputEnvelope {
  data: [DriverVehicleImgCreateManyVehicleInput!]!
  skipDuplicates: Boolean
}

input DriverVehicleImgCreateNestedManyWithoutVehicleInput {
  connect: [DriverVehicleImgWhereUniqueInput!]
  connectOrCreate: [DriverVehicleImgCreateOrConnectWithoutVehicleInput!]
  create: [DriverVehicleImgCreateWithoutVehicleInput!]
  createMany: DriverVehicleImgCreateManyVehicleInputEnvelope
}

input DriverVehicleImgCreateOrConnectWithoutVehicleInput {
  create: DriverVehicleImgCreateWithoutVehicleInput!
  where: DriverVehicleImgWhereUniqueInput!
}

input DriverVehicleImgCreateWithoutVehicleInput {
  category: String
  id: String
  url: String
}

input DriverVehicleImgListRelationFilter {
  every: DriverVehicleImgWhereInput
  none: DriverVehicleImgWhereInput
  some: DriverVehicleImgWhereInput
}

type DriverVehicleImgMaxAggregate {
  category: String
  id: String
  url: String
  vehicleId: String
}

type DriverVehicleImgMinAggregate {
  category: String
  id: String
  url: String
  vehicleId: String
}

input DriverVehicleImgWhereInput {
  AND: [DriverVehicleImgWhereInput!]
  NOT: [DriverVehicleImgWhereInput!]
  OR: [DriverVehicleImgWhereInput!]
  category: StringNullableFilter
  id: StringFilter
  url: StringNullableFilter
  vehicle: DriverVehicleScalarRelationFilter
  vehicleId: StringFilter
}

input DriverVehicleImgWhereUniqueInput {
  AND: [DriverVehicleImgWhereInput!]
  NOT: [DriverVehicleImgWhereInput!]
  OR: [DriverVehicleImgWhereInput!]
  category: StringNullableFilter
  id: String
  url: StringNullableFilter
  vehicle: DriverVehicleScalarRelationFilter
  vehicleId: StringFilter
}

input DriverVehicleListRelationFilter {
  every: DriverVehicleWhereInput
  none: DriverVehicleWhereInput
  some: DriverVehicleWhereInput
}

type DriverVehicleMaxAggregate {
  brand: String
  id: String
  model: String
  place: Int
  registrationNumber: String
  userId: String
  vehicleTypeId: String
}

type DriverVehicleMinAggregate {
  brand: String
  id: String
  model: String
  place: Int
  registrationNumber: String
  userId: String
  vehicleTypeId: String
}

input DriverVehicleOrderByRelationAggregateInput {
  _count: SortOrder
}

input DriverVehicleScalarRelationFilter {
  is: DriverVehicleWhereInput
  isNot: DriverVehicleWhereInput
}

type DriverVehicleSumAggregate {
  place: Int
}

input DriverVehicleWhereInput {
  AND: [DriverVehicleWhereInput!]
  DriverVehicleImg: DriverVehicleImgListRelationFilter
  NOT: [DriverVehicleWhereInput!]
  OR: [DriverVehicleWhereInput!]
  brand: StringNullableFilter
  id: StringFilter
  model: StringNullableFilter
  place: IntFilter
  registrationNumber: StringNullableFilter
  type: VehicleTypeScalarRelationFilter
  user: UserScalarRelationFilter
  userId: StringFilter
  vehicleTypeId: StringFilter
}

input DriverVehicleWhereUniqueInput {
  AND: [DriverVehicleWhereInput!]
  DriverVehicleImg: DriverVehicleImgListRelationFilter
  NOT: [DriverVehicleWhereInput!]
  OR: [DriverVehicleWhereInput!]
  brand: StringNullableFilter
  id: String
  model: StringNullableFilter
  place: IntFilter
  registrationNumber: StringNullableFilter
  type: VehicleTypeScalarRelationFilter
  user: UserScalarRelationFilter
  userId: StringFilter
  vehicleTypeId: StringFilter
}

input EnumImageTypeFilter {
  equals: ImageType
  in: [ImageType!]
  not: NestedEnumImageTypeFilter
  notIn: [ImageType!]
}

type FileUploadResult {
  url: String!
}

type ForgotPasswordOutput {
  email: String!
  resetLink: String!
}

enum ImageType {
  PROFILE
  USER
  VEHICULE
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input LoginInput {
  email: String!
  password: String!
}

type LoginOutput {
  token: String
  user: User
}

type Mutation {
  createUser(input: UserRegistrationInput!): User!
  forgotPassword(email: String!): ForgotPasswordOutput!
  login(data: LoginInput!): LoginOutput
  logout: Boolean!
  register(data: RegisterInput!): User!
  resetPassword(newPassword: String!, sessionToken: String!): Boolean!
  uploadFile(file: Upload!, path: String): FileUploadResult!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumImageTypeFilter {
  equals: ImageType
  in: [ImageType!]
  not: NestedEnumImageTypeFilter
  notIn: [ImageType!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Query {
  me: User!
  s3EnsureBucket(bucket: String!): String!
  s3List(bucket: String!): [String!]!
  user(id: String!): User!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  usersForAdmin(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type RefreshToken {
  createdAt: DateTime!
  expiresAt: DateTime!
  id: String!
  token: String!
  user: User!
  userId: String!
}

type RefreshTokenCountAggregate {
  _all: Int!
  createdAt: Int!
  expiresAt: Int!
  id: Int!
  token: Int!
  userId: Int!
}

input RefreshTokenCreateManyUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  id: String
  token: String!
}

input RefreshTokenCreateManyUserInputEnvelope {
  data: [RefreshTokenCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input RefreshTokenCreateNestedManyWithoutUserInput {
  connect: [RefreshTokenWhereUniqueInput!]
  connectOrCreate: [RefreshTokenCreateOrConnectWithoutUserInput!]
  create: [RefreshTokenCreateWithoutUserInput!]
  createMany: RefreshTokenCreateManyUserInputEnvelope
}

input RefreshTokenCreateOrConnectWithoutUserInput {
  create: RefreshTokenCreateWithoutUserInput!
  where: RefreshTokenWhereUniqueInput!
}

input RefreshTokenCreateWithoutUserInput {
  createdAt: DateTime
  expiresAt: DateTime!
  id: String
  token: String!
}

input RefreshTokenListRelationFilter {
  every: RefreshTokenWhereInput
  none: RefreshTokenWhereInput
  some: RefreshTokenWhereInput
}

type RefreshTokenMaxAggregate {
  createdAt: DateTime
  expiresAt: DateTime
  id: String
  token: String
  userId: String
}

type RefreshTokenMinAggregate {
  createdAt: DateTime
  expiresAt: DateTime
  id: String
  token: String
  userId: String
}

input RefreshTokenOrderByRelationAggregateInput {
  _count: SortOrder
}

input RefreshTokenWhereInput {
  AND: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: StringFilter
  token: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input RefreshTokenWhereUniqueInput {
  AND: [RefreshTokenWhereInput!]
  NOT: [RefreshTokenWhereInput!]
  OR: [RefreshTokenWhereInput!]
  createdAt: DateTimeFilter
  expiresAt: DateTimeFilter
  id: String
  token: String
  user: UserScalarRelationFilter
  userId: StringFilter
}

input RegisterInput {
  email: String!
  firstName: String!
  lastName: String
  password: String!
  username: String
}

type Role {
  _count: RoleCount!
  id: String!
  name: String!
  users: [User!]
}

type RoleCount {
  users: Int!
}

type RoleCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input RoleCreateNestedManyWithoutUsersInput {
  connect: [RoleWhereUniqueInput!]
  connectOrCreate: [RoleCreateOrConnectWithoutUsersInput!]
  create: [RoleCreateWithoutUsersInput!]
}

input RoleCreateOrConnectWithoutUsersInput {
  create: RoleCreateWithoutUsersInput!
  where: RoleWhereUniqueInput!
}

input RoleCreateWithoutUsersInput {
  id: String
  name: String!
}

input RoleListRelationFilter {
  every: RoleWhereInput
  none: RoleWhereInput
  some: RoleWhereInput
}

type RoleMaxAggregate {
  id: String
  name: String
}

type RoleMinAggregate {
  id: String
  name: String
}

input RoleOrderByRelationAggregateInput {
  _count: SortOrder
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input RoleWhereUniqueInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  id: String
  name: String
  users: UserListRelationFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  Documets: [Documets!]
  DriverIDCards: [DriverIDCards!]
  DriverLicense: [DriverLicense!]
  Role: [Role!]
  UserPreference: UserPreference
  _count: UserCount!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  images: [UserImage!]
  isVerified: Boolean!
  lastName: String
  password: String!
  phone: String
  tokens: [RefreshToken!]
  updatedAt: DateTime
  username: String
  vehicles: [DriverVehicle!]
}

type UserCount {
  Documets: Int!
  DriverIDCards: Int!
  DriverLicense: Int!
  Role: Int!
  images: Int!
  tokens: Int!
  vehicles: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  firstName: Int!
  id: Int!
  isVerified: Int!
  lastName: Int!
  password: Int!
  phone: Int!
  updatedAt: Int!
  username: Int!
}

input UserCreateInput {
  Documets: DocumetsCreateNestedManyWithoutUserInput
  DriverIDCards: DriverIDCardsCreateNestedManyWithoutUserInput
  DriverLicense: DriverLicenseCreateNestedManyWithoutUserInput
  Role: RoleCreateNestedManyWithoutUsersInput
  UserPreference: UserPreferenceCreateNestedOneWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  images: UserImageCreateNestedManyWithoutUserInput
  isVerified: Boolean
  lastName: String
  password: String!
  phone: String
  tokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  vehicles: DriverVehicleCreateNestedManyWithoutUserInput
}

input UserCreateNestedOneWithoutUserPreferenceInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutUserPreferenceInput
  create: UserCreateWithoutUserPreferenceInput
}

input UserCreateNestedOneWithoutVehiclesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutVehiclesInput
  create: UserCreateWithoutVehiclesInput
}

input UserCreateOrConnectWithoutUserPreferenceInput {
  create: UserCreateWithoutUserPreferenceInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutVehiclesInput {
  create: UserCreateWithoutVehiclesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutUserPreferenceInput {
  Documets: DocumetsCreateNestedManyWithoutUserInput
  DriverIDCards: DriverIDCardsCreateNestedManyWithoutUserInput
  DriverLicense: DriverLicenseCreateNestedManyWithoutUserInput
  Role: RoleCreateNestedManyWithoutUsersInput
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  images: UserImageCreateNestedManyWithoutUserInput
  isVerified: Boolean
  lastName: String
  password: String!
  phone: String
  tokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
  vehicles: DriverVehicleCreateNestedManyWithoutUserInput
}

input UserCreateWithoutVehiclesInput {
  Documets: DocumetsCreateNestedManyWithoutUserInput
  DriverIDCards: DriverIDCardsCreateNestedManyWithoutUserInput
  DriverLicense: DriverLicenseCreateNestedManyWithoutUserInput
  Role: RoleCreateNestedManyWithoutUsersInput
  UserPreference: UserPreferenceCreateNestedOneWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  images: UserImageCreateNestedManyWithoutUserInput
  isVerified: Boolean
  lastName: String
  password: String!
  phone: String
  tokens: RefreshTokenCreateNestedManyWithoutUserInput
  updatedAt: DateTime
  username: String
}

type UserImage {
  id: String!
  type: ImageType!
  url: String!
  user: User!
  userId: String!
}

type UserImageCountAggregate {
  _all: Int!
  id: Int!
  type: Int!
  url: Int!
  userId: Int!
}

input UserImageCreateManyUserInput {
  id: String
  type: ImageType!
  url: String!
}

input UserImageCreateManyUserInputEnvelope {
  data: [UserImageCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserImageCreateNestedManyWithoutUserInput {
  connect: [UserImageWhereUniqueInput!]
  connectOrCreate: [UserImageCreateOrConnectWithoutUserInput!]
  create: [UserImageCreateWithoutUserInput!]
  createMany: UserImageCreateManyUserInputEnvelope
}

input UserImageCreateOrConnectWithoutUserInput {
  create: UserImageCreateWithoutUserInput!
  where: UserImageWhereUniqueInput!
}

input UserImageCreateWithoutUserInput {
  id: String
  type: ImageType!
  url: String!
}

input UserImageListRelationFilter {
  every: UserImageWhereInput
  none: UserImageWhereInput
  some: UserImageWhereInput
}

type UserImageMaxAggregate {
  id: String
  type: ImageType
  url: String
  userId: String
}

type UserImageMinAggregate {
  id: String
  type: ImageType
  url: String
  userId: String
}

input UserImageOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserImageWhereInput {
  AND: [UserImageWhereInput!]
  NOT: [UserImageWhereInput!]
  OR: [UserImageWhereInput!]
  id: StringFilter
  type: EnumImageTypeFilter
  url: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserImageWhereUniqueInput {
  AND: [UserImageWhereInput!]
  NOT: [UserImageWhereInput!]
  OR: [UserImageWhereInput!]
  id: String
  type: EnumImageTypeFilter
  url: StringFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  isVerified: Boolean
  lastName: String
  password: String
  phone: String
  updatedAt: DateTime
  username: String
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  isVerified: Boolean
  lastName: String
  password: String
  phone: String
  updatedAt: DateTime
  username: String
}

input UserOrderByWithRelationInput {
  Documets: DocumetsOrderByRelationAggregateInput
  DriverIDCards: DriverIDCardsOrderByRelationAggregateInput
  DriverLicense: DriverLicenseOrderByRelationAggregateInput
  Role: RoleOrderByRelationAggregateInput
  UserPreference: UserPreferenceOrderByWithRelationInput
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  images: UserImageOrderByRelationAggregateInput
  isVerified: SortOrder
  lastName: SortOrderInput
  password: SortOrder
  phone: SortOrderInput
  tokens: RefreshTokenOrderByRelationAggregateInput
  updatedAt: SortOrderInput
  username: SortOrderInput
  vehicles: DriverVehicleOrderByRelationAggregateInput
}

type UserPreference {
  _count: UserPreferenceCount!
  activateLocation: Boolean!
  activateNotifications: Boolean!
  createdAt: DateTime!
  id: String!
  language: String
  preferedVehicules: [VehicleType!]
  theme: String
  updatedAt: DateTime
  user: User!
  userId: String!
}

type UserPreferenceCount {
  preferedVehicules: Int!
}

type UserPreferenceCountAggregate {
  _all: Int!
  activateLocation: Int!
  activateNotifications: Int!
  createdAt: Int!
  id: Int!
  language: Int!
  theme: Int!
  updatedAt: Int!
  userId: Int!
}

input UserPreferenceCreateNestedOneWithoutPreferedVehiculesInput {
  connect: UserPreferenceWhereUniqueInput
  connectOrCreate: UserPreferenceCreateOrConnectWithoutPreferedVehiculesInput
  create: UserPreferenceCreateWithoutPreferedVehiculesInput
}

input UserPreferenceCreateNestedOneWithoutUserInput {
  connect: UserPreferenceWhereUniqueInput
  connectOrCreate: UserPreferenceCreateOrConnectWithoutUserInput
  create: UserPreferenceCreateWithoutUserInput
}

input UserPreferenceCreateOrConnectWithoutPreferedVehiculesInput {
  create: UserPreferenceCreateWithoutPreferedVehiculesInput!
  where: UserPreferenceWhereUniqueInput!
}

input UserPreferenceCreateOrConnectWithoutUserInput {
  create: UserPreferenceCreateWithoutUserInput!
  where: UserPreferenceWhereUniqueInput!
}

input UserPreferenceCreateWithoutPreferedVehiculesInput {
  activateLocation: Boolean
  activateNotifications: Boolean
  createdAt: DateTime
  id: String
  language: String
  theme: String
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutUserPreferenceInput!
}

input UserPreferenceCreateWithoutUserInput {
  activateLocation: Boolean
  activateNotifications: Boolean
  createdAt: DateTime
  id: String
  language: String
  preferedVehicules: VehicleTypeCreateNestedManyWithoutUserPreferenceInput
  theme: String
  updatedAt: DateTime
}

type UserPreferenceMaxAggregate {
  activateLocation: Boolean
  activateNotifications: Boolean
  createdAt: DateTime
  id: String
  language: String
  theme: String
  updatedAt: DateTime
  userId: String
}

type UserPreferenceMinAggregate {
  activateLocation: Boolean
  activateNotifications: Boolean
  createdAt: DateTime
  id: String
  language: String
  theme: String
  updatedAt: DateTime
  userId: String
}

input UserPreferenceNullableScalarRelationFilter {
  is: UserPreferenceWhereInput
  isNot: UserPreferenceWhereInput
}

input UserPreferenceOrderByWithRelationInput {
  activateLocation: SortOrder
  activateNotifications: SortOrder
  createdAt: SortOrder
  id: SortOrder
  language: SortOrderInput
  preferedVehicules: VehicleTypeOrderByRelationAggregateInput
  theme: SortOrderInput
  updatedAt: SortOrderInput
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input UserPreferenceWhereInput {
  AND: [UserPreferenceWhereInput!]
  NOT: [UserPreferenceWhereInput!]
  OR: [UserPreferenceWhereInput!]
  activateLocation: BoolFilter
  activateNotifications: BoolFilter
  createdAt: DateTimeFilter
  id: StringFilter
  language: StringNullableFilter
  preferedVehicules: VehicleTypeListRelationFilter
  theme: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  user: UserScalarRelationFilter
  userId: StringFilter
}

input UserPreferenceWhereUniqueInput {
  AND: [UserPreferenceWhereInput!]
  NOT: [UserPreferenceWhereInput!]
  OR: [UserPreferenceWhereInput!]
  activateLocation: BoolFilter
  activateNotifications: BoolFilter
  createdAt: DateTimeFilter
  id: String
  language: StringNullableFilter
  preferedVehicules: VehicleTypeListRelationFilter
  theme: StringNullableFilter
  updatedAt: DateTimeNullableFilter
  user: UserScalarRelationFilter
  userId: String
}

input UserRegistrationInput {
  driver: DriverRegistrationInput!
  user: UserCreateInput!
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  isVerified
  lastName
  password
  phone
  updatedAt
  username
}

input UserScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Documets: DocumetsListRelationFilter
  DriverIDCards: DriverIDCardsListRelationFilter
  DriverLicense: DriverLicenseListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Role: RoleListRelationFilter
  UserPreference: UserPreferenceNullableScalarRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  images: UserImageListRelationFilter
  isVerified: BoolFilter
  lastName: StringNullableFilter
  password: StringFilter
  phone: StringNullableFilter
  tokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeNullableFilter
  username: StringNullableFilter
  vehicles: DriverVehicleListRelationFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  Documets: DocumetsListRelationFilter
  DriverIDCards: DriverIDCardsListRelationFilter
  DriverLicense: DriverLicenseListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Role: RoleListRelationFilter
  UserPreference: UserPreferenceNullableScalarRelationFilter
  createdAt: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  images: UserImageListRelationFilter
  isVerified: BoolFilter
  lastName: StringNullableFilter
  password: StringFilter
  phone: StringNullableFilter
  tokens: RefreshTokenListRelationFilter
  updatedAt: DateTimeNullableFilter
  username: String
  vehicles: DriverVehicleListRelationFilter
}

input VehicleInput {
  assuranceImages: [Upload!]!
  brand: String!
  model: String!
  place: Int!
  registrationImages: [Upload!]!
  registrationNumber: String!
  vehicleImages: [Upload!]!
  vehicleType: String!
}

type VehicleType {
  UserPreference: UserPreference
  _count: VehicleTypeCount!
  id: String!
  name: String!
  userPreferenceId: String
  vehicles: [DriverVehicle!]
}

type VehicleTypeCount {
  vehicles: Int!
}

type VehicleTypeCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  userPreferenceId: Int!
}

input VehicleTypeCreateManyUserPreferenceInput {
  id: String
  name: String!
}

input VehicleTypeCreateManyUserPreferenceInputEnvelope {
  data: [VehicleTypeCreateManyUserPreferenceInput!]!
  skipDuplicates: Boolean
}

input VehicleTypeCreateNestedManyWithoutUserPreferenceInput {
  connect: [VehicleTypeWhereUniqueInput!]
  connectOrCreate: [VehicleTypeCreateOrConnectWithoutUserPreferenceInput!]
  create: [VehicleTypeCreateWithoutUserPreferenceInput!]
  createMany: VehicleTypeCreateManyUserPreferenceInputEnvelope
}

input VehicleTypeCreateNestedOneWithoutVehiclesInput {
  connect: VehicleTypeWhereUniqueInput
  connectOrCreate: VehicleTypeCreateOrConnectWithoutVehiclesInput
  create: VehicleTypeCreateWithoutVehiclesInput
}

input VehicleTypeCreateOrConnectWithoutUserPreferenceInput {
  create: VehicleTypeCreateWithoutUserPreferenceInput!
  where: VehicleTypeWhereUniqueInput!
}

input VehicleTypeCreateOrConnectWithoutVehiclesInput {
  create: VehicleTypeCreateWithoutVehiclesInput!
  where: VehicleTypeWhereUniqueInput!
}

input VehicleTypeCreateWithoutUserPreferenceInput {
  id: String
  name: String!
  vehicles: DriverVehicleCreateNestedManyWithoutTypeInput
}

input VehicleTypeCreateWithoutVehiclesInput {
  UserPreference: UserPreferenceCreateNestedOneWithoutPreferedVehiculesInput
  id: String
  name: String!
}

input VehicleTypeListRelationFilter {
  every: VehicleTypeWhereInput
  none: VehicleTypeWhereInput
  some: VehicleTypeWhereInput
}

type VehicleTypeMaxAggregate {
  id: String
  name: String
  userPreferenceId: String
}

type VehicleTypeMinAggregate {
  id: String
  name: String
  userPreferenceId: String
}

input VehicleTypeOrderByRelationAggregateInput {
  _count: SortOrder
}

input VehicleTypeScalarRelationFilter {
  is: VehicleTypeWhereInput
  isNot: VehicleTypeWhereInput
}

input VehicleTypeWhereInput {
  AND: [VehicleTypeWhereInput!]
  NOT: [VehicleTypeWhereInput!]
  OR: [VehicleTypeWhereInput!]
  UserPreference: UserPreferenceNullableScalarRelationFilter
  id: StringFilter
  name: StringFilter
  userPreferenceId: StringNullableFilter
  vehicles: DriverVehicleListRelationFilter
}

input VehicleTypeWhereUniqueInput {
  AND: [VehicleTypeWhereInput!]
  NOT: [VehicleTypeWhereInput!]
  OR: [VehicleTypeWhereInput!]
  UserPreference: UserPreferenceNullableScalarRelationFilter
  id: String
  name: String
  userPreferenceId: StringNullableFilter
  vehicles: DriverVehicleListRelationFilter
}