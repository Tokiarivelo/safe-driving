generator client {
  provider               = "prisma-client-js"
  generatedFileExtension = "ts"
  importFileExtension    = "ts"
  moduleFormat           = "cjs"
  runtime                = "nodejs"
}

generator nestgraphql {
  provider                              = "prisma-nestjs-graphql"
  output                                = "../src/dtos/@generated"
  dtoInputNameSuffix                    = "Input"
  dtoModelNameSuffix                    = "Model"
  prismaClientImport                    = "@prisma/client"
  fields_Validator_from                 = "class-validator"
  fields_Validator_input                = true
  requireSingleFieldsInWhereUniqueInput = true
  emitSingle                            = true
  // emitCompiled                          = true
  purgeOutput                           = true
  noTypeId                              = true
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id    String @id @default(uuid())
  name  String @unique
  users User[] @relation("UserRoles")
}

model UserCover {
  id        String    @id @default(uuid())
  userId    String    @unique
  fileId    String
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  file File @relation(fields: [fileId], references: [id])
  User User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Disponible, Occup√©, En pause, Non disponible
enum UserDriverStatus {
  AVAILABLE
  BUSY
  PAUSED
  UNAVAILABLE
}

// En ligne, Hors ligne, En conduite, Ne pas d√©ranger
enum UserStatus {
  ONLINE
  OFFLINE
  DRIVING
  DO_NOT_DISTURB
}

model User {
  id         String    @id @default(uuid())
  email      String    @unique
  firstName  String
  lastName   String?
  phone      String?
  username   String?   @unique
  password   String
  isVerified Boolean   @default(false)
  createdAt  DateTime  @default(now())
  avatarId   String? // relation vers File
  avatar     File?     @relation(fields: [avatarId], references: [id])
  updatedAt  DateTime? @updatedAt

  tokens                  RefreshToken[]
  Role                    Role[]                    @relation("UserRoles")
  vehicles                DriverVehicle[]
  rides                   Ride[]
  UserPreference          UserPreference?
  UserImage               UserImage[]
  UserDocument            UserDocument[]
  review                  Review[]
  RideParticipant         RideParticipant[]
  Message                 Message[]
  ConversationParticipant ConversationParticipant[]
  Reaction                Reaction[]
  MessageReadReceipt      MessageReadReceipt[]
  status                  UserStatus?               @default(OFFLINE)
  driverStatus            UserDriverStatus?         @default(AVAILABLE)

  QrToken               QrToken[]
  userCoverId           String?
  UserCover             UserCover?
  notifications         Notification[]
  sentNotifications     Notification[]            @relation("NotificationSender")
}

// --------------- Token -----------------------//
model QrToken {
  id        String   @id @default(uuid())
  token     String   @unique // token opaque long
  userId    String
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)
  // neverExpires boolean omitted since user asked "n'expire jamais"
  user      User     @relation(fields: [userId], references: [id])
}

model Review {
  id        String    @id @default(uuid())
  userId    String
  content   String
  rating    Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  user User @relation(fields: [userId], references: [id], map: "review_userId_relation")

  @@index([userId], map: "review_userId_fkey")
  @@map("review")
}

model UserImage {
  id        String    @id @default(uuid())
  userId    String
  fileId    String
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  file File @relation(fields: [fileId], references: [id])
  User User @relation(fields: [userId], references: [id])
}

enum UserDocumentType {
  ID_CARD
  ID_CARD_BACK
  ID_CARD_FRONT
  DRIVER_LICENSE
  DRIVER_LICENSE_BACK
  DRIVER_LICENSE_FRONT
  PASSPORT
  PROOF_OF_ADDRESS
  OTHER
}

model UserDocument {
  id           String           @id @default(uuid())
  name         String?
  documentType UserDocumentType
  userId       String
  fileId       String
  createdAt    DateTime         @default(now())
  updatedAt    DateTime?        @updatedAt

  file File @relation(fields: [fileId], references: [id])
  User User @relation(fields: [userId], references: [id])
}

model VehicleImage {
  id              String    @id @default(uuid())
  driverVehicleId String
  fileId          String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime? @updatedAt

  file          File           @relation(fields: [fileId], references: [id])
  DriverVehicle DriverVehicle? @relation(fields: [driverVehicleId], references: [id])
}

enum VehicleDocumentType {
  REGISTRATION
  INSURANCE
  CONTROL
  OTHER
}

model VehicleDocument {
  id              String              @id @default(uuid())
  name            String?
  documentType    VehicleDocumentType
  driverVehicleId String
  fileId          String
  createdAt       DateTime            @default(now())
  updatedAt       DateTime?           @updatedAt

  file          File           @relation(fields: [fileId], references: [id])
  DriverVehicle DriverVehicle? @relation(fields: [driverVehicleId], references: [id])
}

model UserPreference {
  id                         String        @id @default(uuid())
  userId                     String        @unique
  activateLocation           Boolean       @default(false)
  activateNotifications      Boolean       @default(false)
  activateSmsNotifications   Boolean       @default(false)
  activateEmailNotifications Boolean       @default(false)
  language                   String?       @default("fr")
  theme                      String?       @default("light")
  cguAccepted                Boolean       @default(false)
  privacyPolicyAccepted      Boolean       @default(false)
  user                       User          @relation(fields: [userId], references: [id], map: "UserPreference_userId_relation")
  preferedvelicles           VehicleType[] @relation("UserPreferencePreferedvelicles")
  createdAt                  DateTime      @default(now())
  updatedAt                  DateTime?     @updatedAt

  @@index([userId], map: "UserPreference_userId_fkey")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  expiresAt DateTime
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, map: "RefreshToken_userId_relation")

  @@index([userId], map: "RefreshToken_userId_fkey")
}

enum FileType {
  MESSAGE
  USER
  AVATAR
  COVER
  VEHICLE
  LANDING
}

model File {
  id              String            @id @default(uuid())
  url             String?
  key             String            @unique
  originalName    String
  contentType     String?
  size            Int?
  etag            String?
  status          String            @default("pending")
  meta            Json?
  name            String?
  userId          String
  driverVehicleId String?
  type            FileType
  UserImage       UserImage[]
  UserDocument    UserDocument[]
  VehicleImage    VehicleImage[]
  VehicleDocument VehicleDocument[]

  // relation inverse : un File peut √™tre r√©f√©renc√© par plusieurs Attachments
  Attachment Attachment[]
  User       User[]
  UserCover  UserCover[]

  @@index([userId])
}

model VehicleType {
  id             String           @id @default(uuid())
  name           String           @unique
  vehicles       DriverVehicle[]
  UserPreference UserPreference[] @relation("UserPreferencePreferedvelicles")
  Ride           Ride[]
}

model DriverVehicle {
  id                 String            @id @default(uuid())
  userId             String
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade, map: "DriverCar_userId_relation")
  brand              String?
  model              String?
  registrationNumber String?           @unique
  place              Int
  vehicleTypeId      String
  type               VehicleType       @relation(fields: [vehicleTypeId], references: [id])
  VehicleImage       VehicleImage[]
  VehicleDocument    VehicleDocument[]
  Position           Position[]
  CurrentPosition    CurrentPosition[]

  @@index([userId], map: "DriverVehicle_userId_fkey")
}

// Ride status enumeration
enum RideStatus {
  PENDING // En attente
  IN_PROGRESS // En cours
  COMPLETED // Termin√©e
  CANCELLED // Annul√©e
}

model Ride {
  id         String     @id @default(uuid())
  driverId   String?
  status     RideStatus @default(PENDING)
  startedAt  DateTime?
  finishedAt DateTime?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime?  @updatedAt

  // Locations
  departureAddress String?
  departureLat     Decimal? @db.Decimal(10, 7)
  departureLng     Decimal? @db.Decimal(10, 7)
  arrivalAddress   String?
  arrivalLat       Decimal? @db.Decimal(10, 7)
  arrivalLng       Decimal? @db.Decimal(10, 7)

  // Scheduling
  scheduledDeparture DateTime?

  // Pricing
  price    Decimal? @db.Decimal(10, 2)
  currency String?  @default("MGA")

  // Vehicle requirements
  vehicleTypeId String?
  vehicleType   VehicleType? @relation(fields: [vehicleTypeId], references: [id])
  requiredSeats Int?         @default(1)

  // Preferences
  acceptsAnimals   Boolean? @default(false)
  acceptsBaggage   Boolean? @default(true)
  baggageDetails   String?
  otherPreferences String?

  // Driver preferences (for user rides)
  minDriverRating    Float?
  preferredLanguages String[] // e.g., ["Malagasy", "Fran√ßaise"]

  // optional relation to positions
  positions       Position[]
  Driver          User?             @relation(fields: [driverId], references: [id])
  RideParticipant RideParticipant[]
  Message         Message[]
  Attachment      Attachment[]
  Notification    Notification[]

  @@index([driverId, createdAt])
  @@index([status])
  @@index([scheduledDeparture])
}

model RideParticipant {
  id       String   @id @default(uuid())
  rideId   String
  ride     Ride     @relation(fields: [rideId], references: [id])
  userId   String
  user     User     @relation(fields: [userId], references: [id])
  role     String // ex: PASSENGER | GUIDE | OBSERVER
  joinedAt DateTime @default(now())

  @@unique([rideId, userId])
  @@index([userId])
}

model Position {
  id           String   @id @default(uuid())
  vehicleId    String
  rideId       String? // nullable: positions can be associated to a ride
  recordedAt   DateTime @default(now()) // timestamp when the device recorded it
  createdAt    DateTime @default(now()) // insert time in DB
  // lat / lon as Decimal for precision (use Decimal on client)
  latitude     Decimal  @db.Decimal(10, 7)
  longitude    Decimal  @db.Decimal(10, 7)
  altitude     Float? // meters
  speed        Float? // m/s or km/h (standardize)
  heading      Float? // degrees (0-360)
  accuracy     Float? // meters
  provider     String? // gps, fused, network
  battery      Int? // battery percentage on device when reported
  is_mock      Boolean  @default(false) // detect mock locations
  clientTempId String? // optional pour idempotence c√¥t√© client
  // NOTE: geom column (PostGIS point) will be added by raw SQL migration for indexing
  // geom      Unsupported("geometry(Point,4326)")?  // optional in Prisma as Unsupported
  createdBy    String? // user id who submitted (if any)

  vehicle DriverVehicle @relation(fields: [vehicleId], references: [id])
  Ride    Ride?         @relation(fields: [rideId], references: [id])

  @@index([vehicleId, recordedAt])
  @@index([rideId, recordedAt])
  @@index([recordedAt])
}

model CurrentPosition {
  // table with one row per vehicle for fast reads
  vehicleId  String   @id
  latitude   Decimal  @db.Decimal(10, 7)
  longitude  Decimal  @db.Decimal(10, 7)
  altitude   Float?
  speed      Float?
  heading    Float?
  accuracy   Float?
  provider   String?
  battery    Int?
  recordedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt

  vehicle DriverVehicle @relation(fields: [vehicleId], references: [id])
  // optionally store a "geom" PostGIS point via raw SQL
}

/// Models de chat / message

model Message {
  id              String  @id @default(uuid())
  conversationId  String? // nullable : message direct/group ou li√© √† une ride
  rideId          String? // nullable : si message attach√© √† une course
  senderId        String
  content         String? // peut √™tre null si message uniquement attachments
  clientTempId    String? // id provisoire c√¥t√© client pour idempotence
  parentMessageId String? // pour threads / r√©ponses

  edited    Boolean   @default(false)
  editedAt  DateTime?
  deleted   Boolean   @default(false)
  deletedAt DateTime?

  createdAt   DateTime  @default(now())
  sentAt      DateTime?
  deliveredAt DateTime? // optionnel: timestamp global (ou g√©rer par readReceipts)

  ride          Ride?                @relation(fields: [rideId], references: [id])
  conversation  Conversation?        @relation(fields: [conversationId], references: [id])
  sender        User                 @relation(fields: [senderId], references: [id])
  state         MessageState         @default(SENT) // √©tat global (utile pour UI)
  parentMessage Message?             @relation("MessageParent", fields: [parentMessageId], references: [id])
  replies       Message[]            @relation("MessageParent")
  attachments   Attachment[] // fichiers, images, audio
  reactions     Reaction[]
  readReceipts  MessageReadReceipt[] // qui a lu (per-user)

  // indexes pour requ√™tes fr√©quentes
  @@index([conversationId, createdAt])
  @@index([rideId, createdAt])
  @@index([senderId, createdAt])
  @@index([clientTempId])
}

model Conversation {
  id         String   @id @default(uuid())
  title      String?
  rideId     String?  @unique // si type == RIDE_LINKED, unique sur ride
  directHash String?  @unique // ex: 'userA|userB' pour direct 1-1
  // participants via table join (permet r√¥les, mute, joinedAt)
  createdAt  DateTime @default(now())

  type         ConversationType          @default(DIRECT) // DIRECT | GROUP | RIDE_LINKED
  participants ConversationParticipant[]
  messages     Message[]

  @@index([type])
}

model ConversationParticipant {
  id             String    @id @default(uuid())
  conversationId String
  userId         String
  role           String? // ex: ADMIN, MEMBER
  isMuted        Boolean?  @default(false)
  joinedAt       DateTime? @default(now())

  user         User          @relation(fields: [userId], references: [id])
  conversation Conversation? @relation(fields: [conversationId], references: [id])

  @@unique([conversationId, userId])
  @@index([userId])
}

enum AttachmentType {
  FILE
  LINK
  RIDE // ancien EVENT -> RIDE
}

model Attachment {
  id        String         @id @default(uuid())
  messageId String
  message   Message        @relation(fields: [messageId], references: [id])
  type      AttachmentType

  // FILE-specific
  fileId String?
  file   File?   @relation(fields: [fileId], references: [id], onDelete: Restrict)

  // LINK-specific
  url           String?
  linkTitle     String?
  linkDesc      String?
  linkThumbnail String?
  linkMeta      Json?

  // RIDE-specific (lien direct vers Ride)
  rideId String?
  ride   Ride?   @relation(fields: [rideId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([messageId])
  @@index([fileId])
  @@index([rideId])
  @@index([type])
}

model Reaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  type      String // ex: "‚ù§Ô∏è", "üëç", "üö©" or a short code like "like", "laugh"
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  @@unique([messageId, userId, type]) // un utilisateur peut r√©agir 1x par type (√©vite doublons)
  @@index([messageId])
  @@index([userId])
}

model MessageReadReceipt {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  @@unique([messageId, userId]) // un seul "read" par user/message
  @@index([userId, readAt])
  @@index([messageId])
}

enum MessageState {
  SENT
  DELIVERED
  READ
  FAILED
}

enum ConversationType {
  DIRECT
  GROUP
  RIDE_LINKED
}

// ==================== Notification System ====================

enum NotificationType {
  RIDE_CONFIRMED       // Course confirm√©e
  DRIVER_EN_ROUTE      // Chauffeur en route
  DRIVER_ARRIVED       // Chauffeur arriv√©
  RIDE_STARTED         // Course d√©marr√©e
  RIDE_COMPLETED       // Course termin√©e
  NEW_MESSAGE          // Nouveau message
  MISSED_CALL          // Appel manqu√©
  PROMOTION            // Offre & promotion
  RIDE_REMINDER        // Rappel de course programm√©e
  REVIEW_REQUEST       // Invitation √† donner un avis
  DRIVER_REVIEW        // Avis re√ßu du chauffeur sur l'utilisateur
  SECURITY_ALERT       // Alerte de s√©curit√© / incident
}

model Notification {
  id          String           @id @default(uuid())
  userId      String           // User who receives the notification
  type        NotificationType
  title       String
  message     String
  read        Boolean          @default(false)
  archived    Boolean          @default(false)
  deleted     Boolean          @default(false)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime?        @updatedAt
  readAt      DateTime?
  
  // Optional references for context
  rideId      String?          // Related ride if applicable
  senderId    String?          // Sender user (e.g., driver or passenger)
  metadata    Json?            // Additional data like price, location, etc.

  // Relations
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  sender      User?            @relation("NotificationSender", fields: [senderId], references: [id])
  ride        Ride?            @relation(fields: [rideId], references: [id])

  @@index([userId, createdAt])
  @@index([userId, read])
  @@index([type])
}
